#!/bin/bash
#
#
# ARG_OPTIONAL_BOOLEAN([oob],[o],[connect to the BMC instead of the host])
# ARG_OPTIONAL_SINGLE([host],[],[host])
# ARG_OPTIONAL_SINGLE([host_list],[H],[list of hosts])
# ARG_OPTIONAL_SINGLE([log_dir],[d],[where to dump output of command ran on hosts])
# ARG_OPTIONAL_SINGLE([dep],[],[Directory that contain dependent scripts. Dependencies will be dumped to /tmp/pmssh_bin directory for each host.])
# ARG_OPTIONAL_SINGLE([script],[s],[script to run on host])
# ARG_OPTIONAL_SINGLE([command],[c],[command to run on host])
# ARG_HELP([Run a command or script on hosts])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.8.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die()
{
  local _ret=$2
  test -n "$_ret" || _ret=1
  test "$_PRINT_HELP" = yes && print_help >&2
  echo "$1" >&2
  exit ${_ret}
}


begins_with_short_option()
{
  local first_option all_short_options='oHdsch'
  first_option="${1:0:1}"
  test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_oob="off"
_arg_host=
_arg_host_list=
_arg_log_dir=
_arg_dep=
_arg_script=
_arg_command=


print_help()
{
  printf '%s\n' "Run a command or script on hosts"
  printf 'Usage: %s [-o|--(no-)oob] [--host <arg>] [-H|--host_list <arg>] [-d|--log_dir <arg>] [--dep <arg>] [-s|--script <arg>] [-c|--command <arg>] [-h|--help]\n' "$0"
  printf '\t%s\n' "-o, --oob, --no-oob: connect to the BMC instead of the host (off by default)"
  printf '\t%s\n' "--host: host (no default)"
  printf '\t%s\n' "-H, --host_list: list of hosts (no default)"
  printf '\t%s\n' "-d, --log_dir: where to dump output of command ran on hosts (no default)"
  printf '\t%s\n' "--dep: Directory that contain dependent scripts. Dependencies will be dumped to /tmp/pmssh_bin directory for each host. (no default)"
  printf '\t%s\n' "-s, --script: script to run on host (no default)"
  printf '\t%s\n' "-c, --command: command to run on host (no default)"
  printf '\t%s\n' "-h, --help: Prints help"
}


parse_commandline()
{
  while test $# -gt 0
  do
    _key="$1"
    case "$_key" in
      -o|--no-oob|--oob)
        _arg_oob="on"
        test "${1:0:5}" = "--no-" && _arg_oob="off"
        ;;
      -o*)
        _arg_oob="on"
        _next="${_key##-o}"
        if test -n "$_next" -a "$_next" != "$_key"
        then
          { begins_with_short_option "$_next" && shift && set -- "-o" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
        fi
        ;;
      --host)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_host="$2"
        shift
        ;;
      --host=*)
        _arg_host="${_key##--host=}"
        ;;
      -H|--host_list)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_host_list="$2"
        shift
        ;;
      --host_list=*)
        _arg_host_list="${_key##--host_list=}"
        ;;
      -H*)
        _arg_host_list="${_key##-H}"
        ;;
      -d|--log_dir)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_log_dir="$2"
        shift
        ;;
      --log_dir=*)
        _arg_log_dir="${_key##--log_dir=}"
        ;;
      -d*)
        _arg_log_dir="${_key##-d}"
        ;;
      --dep)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_dep="$2"
        shift
        ;;
      --dep=*)
        _arg_dep="${_key##--dep=}"
        ;;
      -s|--script)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_script="$2"
        shift
        ;;
      --script=*)
        _arg_script="${_key##--script=}"
        ;;
      -s*)
        _arg_script="${_key##-s}"
        ;;
      -c|--command)
        test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
        _arg_command="$2"
        shift
        ;;
      --command=*)
        _arg_command="${_key##--command=}"
        ;;
      -c*)
        _arg_command="${_key##-c}"
        ;;
      -h|--help)
        print_help
        exit 0
        ;;
      -h*)
        print_help
        exit 0
        ;;
      *)
        _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
        ;;
    esac
    shift
  done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# TODO remove hostname with sed -e "s/^root@$h: //"

if [[ ! -z $_arg_host_list ]]; then
  host_list=`cat $_arg_host_list`
elif [[ ! -z $_arg_host ]]; then
  host_list=$_arg_host
else
  echo "Must provide either a '--host' or a '--host_list'"
  exit 1
fi

for h in $host_list; do

  if [[ $_arg_oob == 'on' ]]; then
    h=`/home/duynguyen1/bin/bash/generate_oob_name.sh $h`
  fi

  if [[ ! -z $_arg_dep ]]; then
    ssh root@$h "rm -rf /tmp/pmssh_bin && mkdir /tmp/pmssh_bin"
    scp -r $_arg_dep root@$h:/tmp/pmssh_bin
  fi

  cmd="mussh -t 10 -l root -h $h"

  if [[ ! -z $_arg_script ]]; then
    cmd="$cmd -C $_arg_script"
  else
    cmd="$cmd -c \"$_arg_command\""
  fi


  if [[ ! -z $_arg_log_dir ]]; then
    mkdir -p $_arg_log_dir
    cmd="$cmd &> \"$_arg_log_dir/$h\""
  else
    # group host output in blocks
    cmd="$cmd -b"
  fi

  bash -c "$cmd &"

done

# ] <-- needed because of Argbash